BeginPackage["Prelude`"]

PackageExports[

  "PackageFunction",
    SystemExports, PackageExports, PrivateExports,
    DeclareFilePrivates,
    DeclareFileLocals,
    DeclarePackagePrivates,
    DeclarePackageLocals,
    DeclarePackageGlobals,
    DeclareSystemPrivates,
    DeclareSystemGlobals,

  "SpecialVariable",
    $PreludeLoaded,
    $PreludeDir,
    $PreludeFiles
];

SystemExports[

  "MutatingFunction",
    UnprotectClearAll, UnprotectClear,

  "IOFunction",
    ToInputString, HoldToInputString, FromInputString,

  "DataHead",
     UAssociation,

  "Function",
     HoldLength, HoldSequenceLength, HoldByteCount,
     HoldSymbolName, HoldSymbolNameAlias, HoldSymbolContext, HoldSymbolPath,
     NaturalNumberString, FullIntegerString,

  "Predicate",
     HoldListQ, HoldAssociationQ, HoldPackedArrayQ, PackedListQ,
     HoldStringQ, HoldIntegerQ, HoldNaturalQ, HoldNumberQ, HoldBooleanQ,

  "Variable",
     $FormalSymbols,

  "ControlFlow",
     PrivateHoldComplete, PrivateSequence, PrivateHoldCompleteSequence,

  "MetaFunction",
    DeclaredHere,

  "FormHead",
    OutputExpressionForm, MessageArgumentForm
];

Begin["`Base`Private`"]

(**************************************************************************************************)

SetAttributes[{UnprotectClearAll, UnprotectClear}, {HoldAllComplete}];

UnprotectClearAll[e___] := (Unprotect[e]; ClearAll[e]);
UnprotectClear[e___]    := (Unprotect[e]; Clear[e]);

SetAttributes[{SystemExports, PackageExports, PrivateExports}, HoldAllComplete];

(**************************************************************************************************)

SetAttributes[HoldToInputString, HoldAllComplete];

HoldToInputString[e_]   := ToString[NoEval @ e, InputForm];
ToInputString[e_]       := ToString[NoEval @ e, InputForm];

SetStrict @ FromInputString;

FromInputString[str_ ? Developer`StringOrStringVectorQ]        := ToExpression[str, InputForm];
FromInputString[str_ ? Developer`StringOrStringVectorQ, head_] := ToExpression[str, InputForm, head];

_FromInputString := (Message[FromInputString::badArgs]; $Failed);

FromInputString::badArgs = "Invalid call to FromInputString.";

(*************************************************************************************************)

(* these can't be cleared! *)
(* MakeBoxes[OutputExpressionForm[e_], StandardForm] := MakeBoxes @ e;
MakeBoxes[MessageArgumentForm[e_], StandardForm]  := MakeBoxes @ e;
 *)
(*************************************************************************************************)

SetAttributes[PrivateHoldComplete, HoldAllComplete];
SetAttributes[privateHoldBoxes, HoldAllComplete];

(* we use this to wrap e.g. held values in Assocs and RuleDelayeds but we know it won't be
shown and won't be generated by any other code that these functions might be trying to debug *)

MakeBoxes[p_PrivateHoldComplete, StandardForm] := privateHoldBoxes[p];

privateHoldBoxes[_]                             := "BAD PrivateHoldComplete";
privateHoldBoxes[PrivateHoldComplete[]]         := RowBox @ {"Sequence", "[", "]"};
privateHoldBoxes[PrivateHoldComplete[e1_]]      := MakeBoxes[e1];
privateHoldBoxes[PrivateHoldComplete[e1_, e2_]] := RowBox @ {"Sequence", "[", RowBox @ {MakeBoxes[e1], ",", MakeBoxes[e2]}, "]"};
privateHoldBoxes[PrivateHoldComplete[es__]]     := RowBox @ {"Sequence", "[", RowBox @ Riffle[{Map[MakeBoxes, Unevaluated @ es]}, ","], "]"};

(*************************************************************************************************)

SetAttributes[PrivateHoldSequence, HoldAllComplete];
SetAttributes[privateSeqBoxes, HoldAllComplete];

MakeBoxes[p_PrivateSequence, StandardForm] := privateSeqBoxes[p];

privateSeqBoxes[_]                      := "BAD PrivateSequence";
privateSeqBoxes[PrivateSequence[es___]] := MakeBoxes[Sequence[es]];

(*************************************************************************************************)

SetAttributes[PrivateHoldCompleteSequence, HoldAllComplete];
SetAttributes[privateHoldSeqBoxes, HoldAllComplete];

MakeBoxes[p_PrivateHoldCompleteSequence, StandardForm] := privateHoldSeqBoxes[p];

privateHoldSeqBoxes[_]                                     := "BAD PrivateHoldCompleteSequence";
privateHoldSeqBoxes[PrivateHoldCompleteSequence[]]         := "";
privateHoldSeqBoxes[PrivateHoldCompleteSequence[e1_]]      := MakeBoxes[e1];
privateHoldSeqBoxes[PrivateHoldCompleteSequence[e1_, e2_]] := RowBox @ {MakeBoxes[e1], ",", MakeBoxes[e2]};
privateHoldSeqBoxes[PrivateHoldCompleteSequence[es__]]     := RowBox @ Riffle[{Map[MakeBoxes, Unevaluated @ es]}, ","];

(*************************************************************************************************)

UAssociation = Data`UnorderedAssociation;
PackedListQ  = Developer`PackedArrayQ;

(* PackedListQ isn't called PackedArrayQ to avoid shadowing problems if someone calls Needs["Developer`"] *)

(*************************************************************************************************)

SetAttributes[{HoldLength, HoldByteCount, HoldSequenceLength}, HoldAllComplete];

HoldByteCount[e_]    := ByteCount @ Unevaluated @ e;
HoldLength[e_]       := Length @ Unevaluated @ e;
e_HoldSequenceLength := Length @ Unevaluated @ e;
e_SequenceLength     := Length @ Unevaluated @ e;

(*************************************************************************************************)

SetAttributes[{HoldStringQ, HoldIntegerQ, HoldNaturalQ, HoldNumberQ, HoldBooleanQ}, HoldAllComplete];

HoldStringQ[_String ? Developer`HoldAtomQ] = True;
HoldIntegerQ[_Integer ? Developer`HoldAtomQ] = True;
HoldNaturalQ[(_Integer ? Developer`HoldAtomQ) ? NonNegative] = True;
HoldNumberQ[Alternatives[_Integer, _Real, _Rational] ? Developer`HoldAtomQ] = True;
HoldBooleanQ[False | True] = True;

_HoldStringQ  = False;
_HoldIntegerQ = False;
_HoldNaturalQ = False;
_HoldNumberQ  = False;
_HoldBooleanQ = False;

(*************************************************************************************************)

SetAttributes[{HoldListQ, HoldAssociationQ, HoldPackedArrayQ}, HoldAllComplete];

HoldListQ[_List] = True;

HoldAssociationQ[_Association ? Developer`HoldAtomQ] = True;

HoldPackedArrayQ[a_List] := Developer`PackedArrayQ @ Unevaluated @ a;

_HoldListQ        = False;
_HoldAssociationQ = False;
_HoldPackedArrayQ = False;

(*************************************************************************************************)

SetAttributes[{HoldSymbolNameAlias, HoldSymbolName, HoldSymbolContext, HoldSymbolPath}, HoldAllComplete];

HoldSymbolName::usage = "HoldSymbolName[sym$] gives the name of sym$ without evaluating sym$.";
HoldSymbolContext::usage = "HoldSymbolContext[sym$] gives the full context of sym$ without evaluating sym$.";
HoldSymbolPath::usage = "HoldSymbolPath[sym$] gives the context and name of sym$ without evaluating sym$.";

HoldSymbolName[sym_Symbol ? Developer`HoldAtomQ] := SymbolName @ Unevaluated @ sym;
HoldSymbolName[_] := $Failed;

HoldSymbolNameAlias[sym_Symbol ? Developer`HoldAtomQ] := SymbolName @ Unevaluated @ sym;
HoldSymbolNameAlias[_] := $Failed;

(* TODO: why isn't this just Context? *)
HoldSymbolContext[sym_Symbol ? Developer`HoldAtomQ] := Internal`SymbolContext @ Unevaluated @ sym;
HoldSymbolContext[_] := $Failed;

HoldSymbolPath[sym_Symbol] := StringJoin[HoldSymbolContext @ sym, HoldSymbolName @ sym];
HoldSymbolPath[list_List] := Map[HoldSymbolPath, Unevaluated @ list];
HoldSymbolPath[_] := $Failed;

(*************************************************************************************************)

$FormalSymbols = {
  \[FormalA], \[FormalB], \[FormalC], \[FormalD], \[FormalE],
  \[FormalF], \[FormalG], \[FormalH], \[FormalI], \[FormalJ],
  \[FormalK], \[FormalL], \[FormalM], \[FormalN], \[FormalO],
  \[FormalP], \[FormalQ], \[FormalR], \[FormalS], \[FormalT],
  \[FormalU], \[FormalV], \[FormalW], \[FormalX], \[FormalY],
  \[FormalZ],
  \[FormalCapitalA], \[FormalCapitalB], \[FormalCapitalC],
  \[FormalCapitalD], \[FormalCapitalE], \[FormalCapitalF],
  \[FormalCapitalG], \[FormalCapitalH], \[FormalCapitalI],
  \[FormalCapitalJ], \[FormalCapitalK], \[FormalCapitalL],
  \[FormalCapitalM], \[FormalCapitalN], \[FormalCapitalO],
  \[FormalCapitalP], \[FormalCapitalQ], \[FormalCapitalR],
  \[FormalCapitalS], \[FormalCapitalT], \[FormalCapitalU],
  \[FormalCapitalV], \[FormalCapitalW], \[FormalCapitalX],
  \[FormalCapitalY], \[FormalCapitalZ]
};

(*************************************************************************************************)

(* IntegerString is badly named! *)

NaturalNumberString[n_Integer ? Positive] := IntegerString @ n;
NaturalNumberString[ns_ ? listableNatsQ]  := IntegerString @ items;
NaturalNumberString[expr_]                := (Message[NaturalNumberString::badArg1, expr]; $Failed);

FullIntegerString[n_Integer]                := fullIntStr @ n;
FullIntegerString[ns_List | ns_Association] := If[listableNatsQ @ ns, IntegerString @ ns, fullIntStr @ ns];
FullIntegerString[expr_]                    := (Message[FullIntegerString::badArg1, expr]; $Failed);

listableNatsQ[e_List ? Developer`PackedArrayQ] := TrueQ @ NonNegative @ Min @ e;
listableNatsQ[e:(_List | _Association)]        := TrueQ @ NonNegative @ Min @ e;

(*************************************************************************************************)

SetAttributes[fullIntStr, Listable];

fullIntStr[n_Integer ? Negative] := StringJoin["-", IntegerString @ n];
fullIntStr[n_Integer]            := IntegerString @ n;
fullIntStr[expr_]                := (Message[FullIntegerString::badArg1, expr]; $Failed);

e_NaturalNumberString := Message[NaturalNumberString::badArgCount, HoldForm @ e];
e_FullIntegerString   := Message[FullIntegerString::badArgCount, HoldForm @ e];

NaturalNumberString::badArg1 = "Not a natural number or container of these: ``."
FullIntegerString::badArg1 = "Not an integer or container of these: ``."
NaturalNumberString::badArgCount = FullIntegerString::badArgCount = "Exactly one argument expected: ``."

(*************************************************************************************************)

End[]

EndPackage[]